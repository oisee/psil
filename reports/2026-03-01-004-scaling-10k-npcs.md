# Scaling to 10,000 NPCs: Decoupled Tiles and Bounded Search

**Date:** 2026-03-01
**Status:** Complete
**Previous:** [Simulation Observations](2026-03-01-003-simulation-observations.md)
**See also:** [Temporal Dynamics](2026-03-01-005-temporal-dynamics.md) for time-series charts at multiple scales

---

## Problem

The original tile encoding packed occupant ID into the high 4 bits of a byte:

```
Tile byte = (occupant_id << 4) | tile_type
```

This limited occupant IDs to 0-15 (4 bits), NPC.ID to `byte` with wrapping at 15, and the simulation to ~15 useful NPCs. Running civilization-scale simulations (100-10,000 NPCs) was impossible.

Additionally, all `Nearest*` functions scanned the entire grid (O(size^2) per NPC per tick), making large worlds prohibitively slow.

## Architecture Changes

### 1. Tiles = Pure Terrain

`Tile byte` now uses all 8 bits for type (256 possible tile types). `MakeTile(typ)` takes one argument. The `Occupant()` method is deleted.

```go
// Before
func MakeTile(typ byte, occupant byte) Tile {
    return Tile((occupant&0x0F)<<4 | (typ & 0x0F))
}

// After
func MakeTile(typ byte) Tile {
    return Tile(typ)
}
```

### 2. Separate Occupancy Grid

A parallel `OccGrid []uint16` tracks which NPC occupies each cell. Three methods provide the interface:

```go
func (w *World) OccAt(x, y int) uint16     // 0 = empty
func (w *World) SetOcc(x, y int, id uint16)
func (w *World) ClearOcc(x, y int)
```

Movement is now: `ClearOcc(old) + SetOcc(new)`. No need to preserve tile types through occupant changes — tiles and occupants are independent.

### 3. NPC.ID = uint16

IDs are monotonically increasing `uint16` (max 65535). No wrapping, no reuse. The `npcByID map[uint16]*NPC` provides O(1) lookup, replacing O(n) linear scans in `findNPC()`, attack/share/teach target resolution, and trade matching.

### 4. Cached Tile Counts

`foodCount` and `itemCount` are maintained incrementally by `SetTile()`, replacing full-grid scans in `FoodCount()` and `ItemCount()`.

### 5. Bounded Manhattan Ring Search

All `Nearest*` functions now expand outward in Manhattan rings (distance 0 to 31):

```go
for d := 0; d <= 31; d++ {
    w.scanManhattanRing(x, y, d, func(fx, fy int) bool {
        // check cell, return true to stop
    })
    if found { return d }
}
```

At distance d, the ring has 4d cells (or 1 at d=0). Total cells scanned for a hit at distance k: `1 + 4 + 8 + ... + 4k = 2k^2 + 2k + 1`. For 10k NPCs on a 400x400 grid (~6% density), the nearest NPC is typically 2-3 tiles away, scanning ~13-25 cells instead of 160,000.

### 6. Combined NPC Sensor

`NearestNPCFull(x, y, excludeID)` returns `(distance, ID, direction)` in a single scan, replacing three separate calls in the sense phase. This eliminates 2/3 of OccGrid NPC searches per tick.

### 7. Auto-Scale World Size

```go
func AutoWorldSize(npcs int) int {
    s := int(math.Sqrt(float64(npcs))) * 4
    if s < 32 { s = 32 }
    return s
}
```

| NPCs | World Size | Density |
|------|-----------|---------|
| 20 | 32x32 | 1.9% |
| 100 | 40x40 | 6.3% |
| 500 | 88x88 | 6.5% |
| 1000 | 128x128 | 6.1% |
| 10000 | 400x400 | 6.3% |

Density stays ~6% regardless of population, keeping spatial interactions consistent.

### 8. Resource Scaling

- `MaxFood = npcs * 3` (was `worldSize * 2`)
- `MaxItems = max(npcs/2, 4)` (was `worldSize / 4`)
- Initial food seeding: `max(worldSize, npcs)` attempts

## Performance Results

All benchmarks: `go run ./cmd/sandbox --npcs N --ticks T --seed 42`

| NPCs | Ticks | World | Time | ms/tick | Trades | Teaches |
|------|-------|-------|------|---------|--------|---------|
| 20 | 10,000 | 32x32 | 1.0s | 0.10 | 93 | 5 |
| 100 | 10,000 | 40x40 | 3.5s | 0.35 | 1,795 | 307 |
| 500 | 10,000 | 88x88 | 19.6s | 1.96 | 10,093 | 3,809 |
| 1,000 | 10,000 | 128x128 | 41s | 4.1 | 17,703 | 8,131 |
| 10,000 | 1,000 | 400x400 | 69s | 69 | 43,358 | 7,084 |

At 1000+ NPCs, the dominant cost is VM brain execution (200 gas per NPC per tick), not world scanning. The bounded search and cached counts keep the world-layer overhead sub-linear.

## Scaling Behavior

### Trades Scale with Population

| NPCs | Trades/10k ticks | Trades/NPC |
|------|------------------|------------|
| 20 | 93 | 4.7 |
| 100 | 1,795 | 18.0 |
| 500 | 10,093 | 20.2 |
| 1,000 | 17,703 | 17.7 |

Trade rate per NPC stabilizes around 18-20, showing genuine emergent economic activity that scales with population.

### Teaching Scales Super-Linearly

| NPCs | Teaches/10k ticks | Teaches/NPC |
|------|-------------------|-------------|
| 20 | 5 | 0.25 |
| 100 | 307 | 3.07 |
| 500 | 3,809 | 7.62 |
| 1,000 | 8,131 | 8.13 |

Higher density increases NPC-NPC contact frequency, producing more teaching events per capita. This means memetic transmission accelerates in larger populations — a realistic emergent property.

### Population Survival

With evolution and respawning, all scale tests maintain viable populations through 10k ticks. The 10k NPC test sustained 2,774 alive through 1,000 ticks (28% survival — expected given the short run and population pressure).

## Files Changed

| File | Change |
|------|--------|
| `pkg/sandbox/npc.go` | `ID byte` -> `ID uint16` |
| `pkg/sandbox/world.go` | 1-arg MakeTile, OccGrid, npcByID, cached counts, bounded Nearest*, NearestNPCFull, AutoWorldSize |
| `pkg/sandbox/scheduler.go` | uint16 trade maps, O(1) findNPC, OccGrid movement/collision, deduplicated NPC sensing |
| `cmd/sandbox/main.go` | Auto-scale world, resource scaling, OccGrid minimap, cluster skip at >500 NPCs |
| `pkg/sandbox/sandbox_test.go` | Updated 30+ MakeTile calls, OccAt checks, uint16 IDs, added TestScaling100NPCs |

## Test Results

- 36 unit tests: all pass
- Crossval tests (Go/Z80 bytecode compatibility): all pass
- TestScaling100NPCs: 100 NPCs on 40x40 world, 5k ticks, >20 alive at end

## Impact on Z80 Port

The Go-side changes are transparent to the Z80 VM — the bytecode format is unchanged. However, a future Z80 sandbox port would need to:

1. Use a separate occupancy byte array instead of packing into tiles
2. Widen NPC IDs from 1 byte to 2 bytes (or keep 1-byte IDs for 16-NPC Z80 limit)
3. The Z80 bounded search is less critical since 16 NPCs on 32x32 is already tiny

The Z80 sandbox (`z80/sandbox.asm`) currently uses its own tile format and is unaffected by this change.
